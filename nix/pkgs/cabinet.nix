# RCade Cabinet Package
#
# Builds the RCade cabinet Electron app reproducibly using bun2nix.
# Dependencies are locked via bun.nix (generated by `bunx bun2nix`).
#
# To update dependencies:
#   1. Run `bun install` to update bun.lock
#   2. Run `bunx bun2nix` to regenerate bun.nix
#   3. Rebuild with `nix build .#cabinet`

{ lib
, stdenv
, makeWrapper
, electron
, bun
, nodejs_22
, bun2nix

  # Runtime dependencies for Electron on Linux
, alsa-lib
, at-spi2-atk
, at-spi2-core
, atk
, cairo
, cups
, dbus
, expat
, gdk-pixbuf
, glib
, gtk3
, libdrm
, libxkbcommon
, mesa
, nspr
, nss
, pango
, systemd
, vulkan-loader
, xorg
, libGL
, pipewire
, libpulseaudio
}:

let
  pname = "rcade-cabinet";
  version = "0.2.1";

  # Runtime library dependencies for Electron
  runtimeLibs = [
    alsa-lib
    at-spi2-atk
    at-spi2-core
    atk
    cairo
    cups
    dbus
    expat
    gdk-pixbuf
    glib
    gtk3
    libdrm
    libxkbcommon
    libGL
    mesa
    nspr
    nss
    pango
    pipewire
    libpulseaudio
    systemd
    vulkan-loader
    xorg.libX11
    xorg.libXcomposite
    xorg.libXdamage
    xorg.libXext
    xorg.libXfixes
    xorg.libXrandr
    xorg.libxcb
    xorg.libxshmfence
  ];

  # Source filtering - exclude build artifacts and unnecessary files
  src = lib.cleanSourceWith {
    src = ../..;
    filter = path: type:
      let
        baseName = baseNameOf path;
      in
      # Exclude build artifacts, caches, and unnecessary files
      !(
        baseName == "node_modules" ||
        baseName == ".git" ||
        baseName == "dist" ||
        baseName == "release" ||
        baseName == ".turbo" ||
        baseName == ".svelte-kit" ||
        baseName == ".vite" ||
        lib.hasPrefix "result" baseName ||
        lib.hasSuffix ".log" baseName
      );
  };

  # Path to the generated bun.nix lockfile
  bunNixPath = ../../bun.nix;

  # Check if bun.nix exists and use bun2nix to create node_modules
  # If bun.nix doesn't exist, we'll create a placeholder that instructs the user
  hasBunNix = builtins.pathExists bunNixPath;

  # Get the bun2nix library functions
  bun2nixLib = bun2nix.lib.${stdenv.hostPlatform.system};

  # Create node_modules from the lockfile
  nodeModules = if hasBunNix then
    bun2nixLib.mkBunNodeModules {
      inherit src;
      bunNix = bunNixPath;
    }
  else
    null;

in
stdenv.mkDerivation {
  inherit pname version src;

  nativeBuildInputs = [ makeWrapper bun nodejs_22 ];

  # Fail fast if bun.nix doesn't exist
  preBuild = lib.optionalString (!hasBunNix) ''
    echo "ERROR: bun.nix not found!"
    echo ""
    echo "To generate it, run from the project root:"
    echo "  bun install"
    echo "  bunx bun2nix"
    echo ""
    echo "This will create bun.nix which locks all npm dependencies"
    echo "for reproducible Nix builds."
    exit 1
  '';

  configurePhase = ''
    runHook preConfigure

    # Link the pre-built node_modules from bun2nix
    echo "Linking node_modules from bun2nix..."
    cp -r ${nodeModules}/node_modules ./node_modules
    chmod -R u+w ./node_modules

    # Link workspace packages (bun2nix creates placeholders for workspace:* deps)
    # We need to replace them with actual local packages
    ${lib.concatStringsSep "\n" (map (ws: ''
      if [ -d "${ws}" ] && [ -d "node_modules/@rcade" ]; then
        pkg_name=$(${nodejs_22}/bin/node -p "require('./${ws}/package.json').name" 2>/dev/null || true)
        if [ -n "$pkg_name" ] && [ -d "node_modules/$pkg_name" ]; then
          echo "Linking workspace package: $pkg_name -> ${ws}"
          rm -rf "node_modules/$pkg_name"
          cp -r "${ws}" "node_modules/$pkg_name"
          chmod -R u+w "node_modules/$pkg_name"
        fi
      fi
    '') [
      "api"
      "sdk/frontend/typescript"
      "sdk/backend"
      "plugins/input-classic"
      "plugins/input-classic/clients/typescript"
      "plugins/input-spinners"
      "plugins/input-spinners/clients/typescript"
      "plugins/sleep"
      "plugins/sleep/clients/typescript"
      "plugins/menu"
      "plugins/menu/clients/typescript"
      "runtime"
      "log"
      "engine"
      "vite-plugins"
    ])}

    runHook postConfigure
  '';

  buildPhase = ''
    runHook preBuild

    export HOME=$(mktemp -d)

    # Build the cabinet app
    echo "Building cabinet main process..."
    cd cabinet
    ${bun}/bin/bun build src/main/main.ts --outdir dist/main --target node --external electron

    echo "Building cabinet preload script..."
    ${bun}/bin/bun build src/main/preload.ts --outdir dist/main --target node --format cjs --external electron

    echo "Building cabinet renderer (vite)..."
    ${nodejs_22}/bin/npx vite build
    cd ..

    runHook postBuild
  '';

  installPhase = ''
    runHook preInstall

    # Create output directories
    mkdir -p $out/lib/rcade-cabinet
    mkdir -p $out/bin

    # Copy the built cabinet app
    cp -r cabinet/dist $out/lib/rcade-cabinet/
    cp cabinet/package.json $out/lib/rcade-cabinet/

    # Copy assets if they exist
    if [ -d cabinet/assets ]; then
      cp -r cabinet/assets $out/lib/rcade-cabinet/
    fi

    # Create wrapper script that launches electron with the app
    cat > $out/bin/rcade-cabinet << 'LAUNCHER'
#!/usr/bin/env bash
set -euo pipefail

APP_DIR="$(dirname "$(dirname "$(readlink -f "$0")")")/lib/rcade-cabinet"

exec electron "$APP_DIR" "$@"
LAUNCHER
    chmod +x $out/bin/rcade-cabinet

    # Wrap with runtime library paths and electron
    wrapProgram $out/bin/rcade-cabinet \
      --prefix PATH : "${lib.makeBinPath [ electron ]}" \
      --prefix LD_LIBRARY_PATH : "${lib.makeLibraryPath runtimeLibs}" \
      --set ELECTRON_DISABLE_SECURITY_WARNINGS "true"

    runHook postInstall
  '';

  meta = with lib; {
    description = "RCade arcade cabinet Electron application";
    homepage = "https://github.com/recursecenter/rcade";
    license = licenses.mit;
    platforms = platforms.linux;
    mainProgram = "rcade-cabinet";
  };
}
